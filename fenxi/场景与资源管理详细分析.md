# Filament 场景与资源管理详细分析

## 概述

Filament 使用 ECS（Entity Component System）架构来管理场景中的所有对象。场景与资源管理系统是 Filament 的核心，负责管理渲染对象、变换、光照等所有场景元素。

## 架构层次

```
┌─────────────────────────────────────────────────────────┐
│  Engine（引擎）                                          │
│  - 资源管理器                                            │
│  - 线程管理                                              │
│  - 组件管理器（TransformManager、RenderableManager等）  │
└──────────────┬──────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────┐
│  Scene（场景）                                          │
│  - Entity 集合管理                                       │
│  - Skybox、IndirectLight 设置                           │
│  - 渲染数据准备（RenderableSoA、LightSoA）              │
└──────────────┬──────────────────────────────────────────┘
               │
       ┌───────┴───────┬───────────┬──────────┐
       ▼               ▼           ▼          ▼
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│Transform │  │Renderable│  │  Light   │  │  Camera  │
│ Manager  │  │ Manager  │  │ Manager  │  │ Manager  │
└──────────┘  └──────────┘  └──────────┘  └──────────┘
       │               │           │          │
       └───────────────┴───────────┴──────────┘
                       │
                       ▼
              ┌─────────────────┐
              │  EntityManager  │
              │  - Entity 创建   │
              │  - 生命周期管理  │
              └─────────────────┘
```

## 核心组件详解

### 1. Engine（引擎）

**位置**: 
- 公共接口：`filament/include/filament/Engine.h`
- 实现：`filament/src/details/Engine.h/cpp`

**职责**：
- **资源管理器**：跟踪所有创建的资源（纹理、缓冲区、材质等）
- **线程管理**：创建并管理渲染线程和工作线程
- **组件管理器**：提供 TransformManager、RenderableManager、LightManager 等
- **Driver 管理**：创建和管理底层 Driver 实例
- **资源创建/销毁**：提供统一的资源创建和销毁接口

**关键特性**：

#### 1.1 资源跟踪
- 自动跟踪所有创建的资源
- 销毁时检查资源泄漏并发出警告
- 提供 `isValid()` 方法验证资源有效性

#### 1.2 线程管理
- **渲染线程**：执行 GPU 命令
- **工作线程**：执行并行任务（剔除、光照计算等）
- 线程优先级根据平台最佳实践自动设置

#### 1.3 配置系统
```cpp
struct Config {
    uint32_t commandBufferSizeMB;           // 命令缓冲区大小
    uint32_t perRenderPassArenaSizeMB;      // 每渲染通道内存池大小
    uint32_t perFrameCommandsSizeMB;        // 每帧命令缓冲区大小
    uint32_t jobSystemThreadCount;          // JobSystem 线程数
    // ... 更多配置
};
```

#### 1.4 组件管理器访问
```cpp
TransformManager& getTransformManager() noexcept;
RenderableManager& getRenderableManager() noexcept;
LightManager& getLightManager() noexcept;
utils::EntityManager& getEntityManager() noexcept;
```

**典型用法**：
```cpp
// 创建引擎
Engine* engine = Engine::create();

// 创建资源
Texture* texture = engine->createTexture(...);
Material* material = engine->createMaterial(...);

// 访问组件管理器
auto& tcm = engine->getTransformManager();
auto& rcm = engine->getRenderableManager();

// 销毁资源
engine->destroy(texture);
engine->destroy(material);
Engine::destroy(&engine);
```

### 2. Scene（场景）

**位置**：
- 公共接口：`filament/include/filament/Scene.h`
- 实现：`filament/src/details/Scene.h/cpp`

**职责**：
- **Entity 集合管理**：维护场景中所有 Entity 的集合
- **环境设置**：管理 Skybox 和 IndirectLight
- **渲染数据准备**：为每帧准备 RenderableSoA 和 LightSoA 数据

**关键特性**：

#### 2.1 Entity 管理
- 使用 `robin_set` 存储 Entity，支持高效的添加/删除
- Entity 必须具有 Renderable 或 Light 组件才能被添加到场景
- 支持批量添加/删除 Entity

#### 2.2 环境设置
```cpp
void setSkybox(Skybox* skybox);              // 设置天空盒
Skybox* getSkybox() const;
void setIndirectLight(IndirectLight* ibl);  // 设置间接光照
IndirectLight* getIndirectLight() const;
```

#### 2.3 渲染数据准备（SoA 布局）

Scene 使用 Structure of Arrays (SoA) 布局存储渲染数据：

**RenderableSoA**：
```cpp
struct RenderableSoA {
    EntityInstance<RenderableManager>[];    // RENDERABLE_INSTANCE
    mat4f[];                                 // WORLD_TRANSFORM
    Visibility[];                            // VISIBILITY_STATE
    SkinningBindingInfo[];                  // SKINNING_BUFFER
    MorphingBindingInfo[];                   // MORPHING_BUFFER
    InstancesInfo[];                         // INSTANCES
    float3[];                                // WORLD_AABB_CENTER
    VisibleMaskType[];                        // VISIBLE_MASK
    uint8_t[];                               // CHANNELS
    // ... 更多字段
};
```

**LightSoA**：
```cpp
struct LightSoA {
    float4[];                                // POSITION_RADIUS
    float3[];                                // DIRECTION
    float3[];                                // SHADOW_DIRECTION
    double2[];                               // SHADOW_REF
    LightManager::Instance[];                // LIGHT_INSTANCE
    Culler::result_type[];                   // VISIBILITY
    float2[];                                // SCREEN_SPACE_Z_RANGE
    ShadowInfo[];                            // SHADOW_INFO
};
```

**SoA 布局的优势**：
- **缓存友好**：相同类型的数据连续存储，提高缓存命中率
- **SIMD 优化**：便于使用 SIMD 指令并行处理
- **内存对齐**：每个数组可以独立对齐，提高访问效率

#### 2.4 prepare() 方法

`prepare()` 是 Scene 的核心方法，在每帧渲染前调用：

```cpp
void prepare(JobSystem& js,
             RootArenaScope& rootArenaScope,
             mat4 const& worldTransform,
             bool shadowReceiversAreCasters);
```

**执行流程**：
1. **收集 Entity**：遍历场景中的所有 Entity，收集 Renderable 和 Light 实例
2. **查找主方向光**：找到强度最大的方向光
3. **调整容量**：根据 Entity 数量调整 SoA 容量（对齐到 16 字节）
4. **并行填充数据**：使用 JobSystem 并行填充 RenderableSoA 和 LightSoA
5. **计算世界变换**：计算每个 Renderable 的世界空间变换
6. **计算包围盒**：计算世界空间包围盒

**典型用法**：
```cpp
// 创建场景
Scene* scene = engine->createScene();

// 添加 Entity
Entity entity = EntityManager::get().create();
scene->addEntity(entity);

// 设置环境
scene->setSkybox(skybox);
scene->setIndirectLight(ibl);

// 在渲染循环中
// View::prepare() 内部会调用 Scene::prepare()
```

### 3. RenderableManager（可渲染对象管理器）

**位置**：
- 公共接口：`filament/include/filament/RenderableManager.h`
- 实现：`filament/src/components/RenderableManager.h/cpp`

**职责**：
- **Renderable 组件管理**：创建、更新、销毁 Renderable 组件
- **图元管理**：管理 Renderable 的多个图元（Primitive）
- **材质绑定**：管理图元与 MaterialInstance 的绑定
- **几何数据**：管理顶点缓冲区、索引缓冲区、包围盒等
- **动画支持**：支持骨骼动画（Skinning）和变形动画（Morphing）

**关键概念**：

#### 3.1 Renderable 组件

Renderable 是一个组件，包含：
- **多个图元（Primitives）**：每个图元有自己的几何和材质
- **渲染属性**：优先级、通道、层掩码、阴影设置等
- **动画数据**：骨骼变换、变形权重等

#### 3.2 Builder 模式

使用 Builder 模式创建 Renderable：

```cpp
RenderableManager::Builder builder(primitiveCount);
builder.boundingBox(aabb)
       .geometry(0, PrimitiveType::TRIANGLES, vb, ib, 0, indexCount)
       .material(0, materialInstance)
       .castShadows(true)
       .receiveShadows(true)
       .priority(4)
       .channel(2)
       .build(engine, entity);
```

**Builder 主要方法**：
- `geometry()`: 设置图元的几何数据
- `material()`: 绑定材质实例
- `boundingBox()`: 设置包围盒（用于视锥剔除）
- `layerMask()`: 设置层掩码（用于可见性控制）
- `priority()`: 设置绘制优先级
- `channel()`: 设置渲染通道
- `castShadows()` / `receiveShadows()`: 阴影设置
- `skinning()`: 启用骨骼动画
- `morphing()`: 启用变形动画
- `instances()`: 设置实例数量

#### 3.3 Instance 和 Entity

- **Entity**：唯一标识符，持久存储
- **Instance**：临时句柄，用于访问组件数据

```cpp
// 获取 Instance
auto instance = renderableManager.getInstance(entity);

// 使用 Instance 修改属性
renderableManager.setCastShadows(instance, true);
renderableManager.setPriority(instance, 5);
```

#### 3.4 运行时更新

```cpp
// 更新包围盒
renderableManager.setAxisAlignedBoundingBox(instance, newAabb);

// 更新材质
renderableManager.setMaterialInstanceAt(instance, 0, newMaterialInstance);

// 更新几何
renderableManager.setGeometryAt(instance, 0, type, vb, ib, offset, count);

// 更新骨骼变换（每帧调用）
renderableManager.setBones(instance, boneTransforms, boneCount);

// 更新变形权重（每帧调用）
renderableManager.setMorphWeights(instance, weights, count);
```

#### 3.5 几何类型

```cpp
enum class GeometryType {
    DYNAMIC,        // 动态几何，无限制
    STATIC_BOUNDS, // 静态边界，包围盒和世界变换不可变
    STATIC          // 完全静态，不允许骨骼/变形，顶点/索引缓冲区不可变
};
```

**典型用法**：
```cpp
// 1. 创建 Entity
Entity entity = EntityManager::get().create();

// 2. 创建 Renderable 组件
RenderableManager::Builder builder(1);
builder.boundingBox(computeAABB(vertices, indices, count))
       .geometry(0, PrimitiveType::TRIANGLES, vb, ib, 0, indexCount)
       .material(0, materialInstance)
       .castShadows(true)
       .build(engine, entity);

// 3. 添加到场景
scene->addEntity(entity);

// 4. 运行时更新
auto instance = renderableManager.getInstance(entity);
renderableManager.setCastShadows(instance, false);
```

### 4. TransformManager（变换管理器）

**位置**：
- 公共接口：`filament/include/filament/TransformManager.h`
- 实现：`filament/src/components/TransformManager.h/cpp`

**职责**：
- **变换组件管理**：创建、更新、销毁 Transform 组件
- **层次结构管理**：管理父子关系
- **世界变换计算**：自动计算世界空间变换
- **高精度变换**：支持双精度平移（用于大世界）

**关键特性**：

#### 4.1 Transform 组件

Transform 组件包含：
- **局部变换（Local Transform）**：相对于父节点的变换
- **世界变换（World Transform）**：相对于根节点的变换（自动计算）
- **父子关系**：支持层次结构

#### 4.2 创建和设置

```cpp
// 创建根节点
transformManager.create(entity);

// 创建子节点
auto parentInstance = transformManager.getInstance(parentEntity);
transformManager.create(entity, parentInstance, localTransform);

// 设置局部变换
auto instance = transformManager.getInstance(entity);
transformManager.setTransform(instance, localTransform);

// 获取世界变换
mat4f worldTransform = transformManager.getWorldTransform(instance);
```

#### 4.3 层次结构

```cpp
// 设置父节点
transformManager.setParent(instance, newParentInstance);

// 获取父节点
Entity parent = transformManager.getParent(instance);

// 获取子节点数量
size_t childCount = transformManager.getChildCount(instance);

// 遍历子节点
auto begin = transformManager.getChildrenBegin(instance);
auto end = transformManager.getChildrenEnd(instance);
for (auto it = begin; it != end; ++it) {
    auto childInstance = *it;
    // 处理子节点
}
```

#### 4.4 高精度变换

对于大世界场景，可以使用双精度平移：

```cpp
// 启用高精度模式
transformManager.setAccurateTranslationsEnabled(true);

// 使用双精度矩阵
mat4 localTransform;  // 双精度
transformManager.setTransform(instance, localTransform);

// 获取高精度世界变换
mat4 worldTransform = transformManager.getWorldTransformAccurate(instance);
```

#### 4.5 批量更新优化

当需要更新大量变换时，使用事务模式：

```cpp
// 开始事务
transformManager.openLocalTransformTransaction();

// 批量更新（此时 getWorldTransform() 可能返回无效值）
for (auto entity : entities) {
    auto instance = transformManager.getInstance(entity);
    transformManager.setTransform(instance, newTransform);
}

// 提交事务（此时 getWorldTransform() 返回正确值）
transformManager.commitLocalTransformTransaction();
```

**典型用法**：
```cpp
// 1. 创建根节点
Entity root = EntityManager::get().create();
transformManager.create(root);
auto rootInstance = transformManager.getInstance(root);
transformManager.setTransform(rootInstance, mat4f::translation({0, 0, 0}));

// 2. 创建子节点
Entity child = EntityManager::get().create();
transformManager.create(child, rootInstance, mat4f::translation({1, 0, 0}));

// 3. 获取世界变换（自动计算）
auto childInstance = transformManager.getInstance(child);
mat4f worldTransform = transformManager.getWorldTransform(childInstance);
// worldTransform 包含根节点和子节点的组合变换
```

### 5. EntityManager（实体管理器）

**位置**：`libs/utils/include/utils/EntityManager.h`

**职责**：
- **Entity 创建/销毁**：管理 Entity 的生命周期
- **Entity ID 分配**：分配唯一的 Entity ID
- **Generation 管理**：使用 Generation 检测 Entity 重用

**关键特性**：

#### 5.1 Entity ID 编码

Entity 的 ID 是一个 32 位整数，编码了：
- **Index（17 位）**：Entity 在数组中的索引
- **Generation（15 位）**：Entity 的生成号，用于检测重用

```
┌─────────────────────────────────────────────────────────┐
│  31        17 16         0                              │
│  ┌──────────┬─────────────┐                            │
│  │ Generation│    Index    │                            │
│  │  (15位)   │   (17位)    │                            │
│  └──────────┴─────────────┘                            │
└─────────────────────────────────────────────────────────┘
```

#### 5.2 使用方式

```cpp
// 获取单例
EntityManager& em = EntityManager::get();

// 创建单个 Entity
Entity entity = em.create();

// 批量创建
Entity entities[100];
em.create(100, entities);

// 销毁 Entity
em.destroy(entity);

// 检查 Entity 是否存活
bool alive = em.isAlive(entity);
```

## 数据流和生命周期

### Entity 创建流程

```
1. EntityManager::create()
   └─> 分配 Entity ID
       └─> 返回 Entity

2. TransformManager::create(entity)
   └─> 创建 Transform 组件
       └─> 存储局部变换

3. RenderableManager::Builder::build(engine, entity)
   └─> 创建 Renderable 组件
       └─> 存储几何和材质数据

4. Scene::addEntity(entity)
   └─> 添加到场景 Entity 集合
       └─> Entity 将在下一帧被渲染
```

### 渲染准备流程

```
1. View::prepare()
   └─> Scene::prepare()
       ├─> 收集所有 Entity
       ├─> 查找 Renderable 和 Light 组件
       ├─> 调整 SoA 容量
       ├─> 并行填充 RenderableSoA
       │   ├─> 计算世界变换
       │   ├─> 计算世界空间包围盒
       │   └─> 收集渲染属性
       └─> 并行填充 LightSoA
           ├─> 计算光照参数
           └─> 计算阴影信息
```

### Entity 销毁流程

```
1. Scene::removeEntity(entity)
   └─> 从场景移除 Entity

2. RenderableManager::destroy(entity)
   └─> 销毁 Renderable 组件
       └─> 释放相关资源

3. TransformManager::destroy(entity)
   └─> 销毁 Transform 组件
       └─> 子节点被孤立

4. EntityManager::destroy(entity)
   └─> 增加 Generation
       └─> Entity ID 可以被重用
```

## 性能优化策略

### 1. SoA 数据布局

**优势**：
- 缓存友好：相同类型数据连续存储
- SIMD 优化：便于向量化处理
- 内存对齐：每个数组独立对齐

**示例**：
```cpp
// AoS（Array of Structures）- 不推荐
struct Renderable {
    mat4f transform;
    Visibility visibility;
    float3 aabbCenter;
};
Renderable renderables[1000];

// SoA（Structure of Arrays）- 推荐
struct RenderableSoA {
    mat4f transforms[1000];
    Visibility visibilities[1000];
    float3 aabbCenters[1000];
};
```

### 2. 批量操作

**批量创建 Entity**：
```cpp
Entity entities[100];
EntityManager::get().create(100, entities);
```

**批量添加 Entity**：
```cpp
scene->addEntities(entities, 100);
```

**批量更新变换**：
```cpp
transformManager.openLocalTransformTransaction();
for (auto entity : entities) {
    // 更新变换
}
transformManager.commitLocalTransformTransaction();
```

### 3. 组件查询优化

**使用 hasComponent() 检查**：
```cpp
if (renderableManager.hasComponent(entity)) {
    auto instance = renderableManager.getInstance(entity);
    // 处理 Renderable
}
```

### 4. 静态几何优化

**使用 STATIC 几何类型**：
```cpp
builder.geometryType(GeometryType::STATIC);
```

**优势**：
- 允许更多优化
- 减少运行时检查
- 提高渲染性能

### 5. 实例化渲染

**使用 instances() 减少绘制调用**：
```cpp
builder.instances(instanceCount, instanceBuffer);
```

**优势**：
- 减少 CPU 开销
- 提高 GPU 利用率
- 支持大量相同对象

## 内存管理

### 1. Arena 分配器

**Per-Render-Pass Arena**：
- 每帧分配，帧结束时自动释放
- 用于临时数据（剔除结果、命令等）

**使用示例**：
```cpp
RootArenaScope rootArenaScope(engine.getPerRenderPassArena());
ArenaScope localArenaScope(rootArenaScope.getArena());
// 使用 localArenaScope 分配临时内存
```

### 2. 资源生命周期

**资源创建**：
```cpp
Texture* texture = engine->createTexture(...);
```

**资源销毁**：
```cpp
engine->destroy(texture);
```

**自动清理**：
- Engine 销毁时自动清理所有资源
- 泄漏的资源会发出警告

### 3. 组件垃圾回收

**GC 流程**：
```cpp
// Component Manager 定期调用 GC
void FRenderableManager::gc(EntityManager& em) {
    mManager.gc(em, [this](Entity e) {
        destroy(e);  // 清理已销毁 Entity 的组件
    });
}
```

## 总结

### Filament 场景与资源管理特点

1. **ECS 架构**
   - Entity 是轻量级标识符
   - Component 存储数据
   - Manager 管理系统

2. **SoA 数据布局**
   - 提高缓存效率
   - 支持 SIMD 优化
   - 便于并行处理

3. **层次化设计**
   - Engine 管理全局资源
   - Scene 管理场景 Entity
   - Manager 管理组件数据

4. **性能优化**
   - 批量操作
   - 静态几何优化
   - 实例化渲染
   - 事务模式

5. **内存管理**
   - Arena 分配器
   - 自动资源跟踪
   - 组件垃圾回收

通过这套系统，Filament 能够高效地管理大量场景对象，支持复杂的渲染场景。

