/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! \file

#ifndef TNT_FILAMENT_INDIRECTLIGHT_H
#define TNT_FILAMENT_INDIRECTLIGHT_H

#include <filament/FilamentAPI.h>

#include <utils/compiler.h>

#include <math/mathfwd.h>

#include <stdint.h>

namespace filament {

class Engine;
class Texture;

class FIndirectLight;

/**
 * IndirectLight is used to simulate environment lighting, a form of global illumination.
 *
 * Environment lighting has a two components:
 *  1. irradiance
 *  2. reflections (specular component)
 *
 * Environments are usually captured as high-resolution HDR equirectangular images and processed
 * by the **cmgen** tool to generate the data needed by IndirectLight.
 *
 * @note
 * Currently IndirectLight is intended to be used for "distant probes", that is, to represent
 * global illumination from a distant (i.e. at infinity) environment, such as the sky or distant
 * mountains. Only a single IndirectLight can be used in a Scene. This limitation will be lifted
 * in the future.
 *
 * Creation and destruction
 * ========================
 *
 * An IndirectLight object is created using the IndirectLight::Builder and destroyed by calling
 * Engine::destroy(const IndirectLight*).
 *
 * ~~~~~~~~~~~{.cpp}
 *  filament::Engine* engine = filament::Engine::create();
 *
 *  filament::IndirectLight* environment = filament::IndirectLight::Builder()
 *              .reflections(cubemap)
 *              .build(*engine);
 *
 *  engine->destroy(environment);
 * ~~~~~~~~~~~
 *
 *
 * Irradiance
 * ==========
 *
 * The irradiance represents the light that comes from the environment and shines an
 * object's surface.
 *
 * The irradiance is calculated automatically from the Reflections (see below), and generally
 * doesn't need to be provided explicitly.  However, it can be provided separately from the
 * Reflections as
 * [spherical harmonics](https://en.wikipedia.org/wiki/Spherical_harmonics) (SH) of 1, 2 or
 * 3 bands, respectively 1, 4 or 9 coefficients.
 *
 * @note
 * Use the **cmgen** tool to generate the `SH` for a given environment.
 *
 * Reflections
 * ===========
 *
 * The reflections on object surfaces (specular component) is calculated from a specially
 * filtered cubemap pyramid generated by the **cmgen** tool.
 *
 *
 * @see Scene, Light, Texture, Skybox
 */
/**
 * IndirectLight 用于模拟环境光照，这是一种全局光照形式。
 *
 * 环境光照有两个组成部分：
 *  1. 辐照度（irradiance）
 *  2. 反射（镜面反射分量）
 *
 * 环境通常被捕获为高分辨率 HDR 等距柱状投影图像，并通过
 * **cmgen** 工具处理以生成 IndirectLight 所需的数据。
 *
 * @note
 * 当前 IndirectLight 旨在用于"远距离探针"，即表示
 * 来自远距离（即无穷远）环境的全局光照，例如天空或远处的
 * 山脉。场景中只能使用单个 IndirectLight。此限制将在未来取消。
 *
 * 创建和销毁
 * ========================
 *
 * IndirectLight 对象使用 IndirectLight::Builder 创建，通过调用
 * Engine::destroy(const IndirectLight*) 销毁。
 *
 * 辐照度
 * ==========
 *
 * 辐照度表示来自环境并照射到
 * 物体表面的光。
 *
 * 辐照度从反射（见下文）自动计算，通常
 * 不需要显式提供。但是，它可以与反射分开提供，作为
 * [球谐函数](https://en.wikipedia.org/wiki/Spherical_harmonics) (SH)，1、2 或
 * 3 个频带，分别对应 1、4 或 9 个系数。
 *
 * @note
 * 使用 **cmgen** 工具为给定环境生成 `SH`。
 *
 * 反射
 * ===========
 *
 * 物体表面的反射（镜面反射分量）由 **cmgen** 工具生成的
 * 特殊过滤的立方体贴图金字塔计算。
 *
 *
 * @see Scene, Light, Texture, Skybox
 */
class UTILS_PUBLIC IndirectLight : public FilamentAPI {
    struct BuilderDetails;

public:

    //! Use Builder to construct an IndirectLight object instance
    /**
     * 使用 Builder 构造 IndirectLight 对象实例
     */
    class Builder : public BuilderBase<BuilderDetails> {
        friend struct BuilderDetails;
    public:
        Builder() noexcept;
        Builder(Builder const& rhs) noexcept;
        Builder(Builder&& rhs) noexcept;
        ~Builder() noexcept;
        Builder& operator=(Builder const& rhs) noexcept;
        Builder& operator=(Builder&& rhs) noexcept;

        /**
         * Set the reflections cubemap mipmap chain.
         *
         * @param cubemap   A mip-mapped cubemap generated by **cmgen**. Each cubemap level
         *                  encodes a the irradiance for a roughness level.
         *
         * @return This Builder, for chaining calls.
         *
         */
        /**
         * 设置反射立方体贴图 mipmap 链。
         *
         * @param cubemap   由 **cmgen** 生成的 mipmap 立方体贴图。每个立方体贴图层级
         *                  编码一个粗糙度级别的辐照度。
         *
         * @return 此 Builder，用于链接调用。
         *
         */
        Builder& reflections(Texture const* UTILS_NULLABLE cubemap) noexcept;

        /**
         * Sets the irradiance as Spherical Harmonics.
         *
         * The irradiance must be pre-convolved by \f$ \langle n \cdot l \rangle \f$ and
         * pre-multiplied by the Lambertian diffuse BRDF \f$ \frac{1}{\pi} \f$ and
         * specified as Spherical Harmonics coefficients.
         *
         * Additionally, these Spherical Harmonics coefficients must be pre-scaled by the
         * reconstruction factors \f$ A_{l}^{m} \f$ below.
         *
         * The final coefficients can be generated using the `cmgen` tool.
         *
         * The index in the \p sh array is given by:
         *
         *  `index(l, m) = l * (l + 1) + m`
         *
         *  \f$ sh[index(l,m)] = L_{l}^{m} \frac{1}{\pi} A_{l}^{m} \hat{C_{l}} \f$
         *
         *   index |  l  |  m  |  \f$ A_{l}^{m} \f$ |  \f$ \hat{C_{l}} \f$  |  \f$ \frac{1}{\pi} A_{l}^{m}\hat{C_{l}} \f$ |
         *  :-----:|:---:|:---:|:------------------:|:---------------------:|:--------------------------------------------:
         *     0   |  0  |  0  |      0.282095      |       3.1415926       |   0.282095
         *     1   |  1  | -1  |     -0.488602      |       2.0943951       |  -0.325735
         *     2   |  ^  |  0  |      0.488602      |       ^               |   0.325735
         *     3   |  ^  |  1  |     -0.488602      |       ^               |  -0.325735
         *     4   |  2  | -2  |      1.092548      |       0.785398        |   0.273137
         *     5   |  ^  | -1  |     -1.092548      |       ^               |  -0.273137
         *     6   |  ^  |  0  |      0.315392      |       ^               |   0.078848
         *     7   |  ^  |  1  |     -1.092548      |       ^               |  -0.273137
         *     8   |  ^  |  2  |      0.546274      |       ^               |   0.136569
         *
         *
         * Only 1, 2 or 3 bands are allowed.
         *
         * @param bands     Number of spherical harmonics bands. Must be 1, 2 or 3.
         * @param sh        Array containing the spherical harmonics coefficients.
         *                  The size of the array must be \f$ bands^{2} \f$.
         *                  (i.e. 1, 4 or 9 coefficients respectively).
         *
         * @return This Builder, for chaining calls.
         *
         * @see Material::Builder::sphericalHarmonicsBandCount()
         *
         * @note
         * Because the coefficients are pre-scaled, `sh[0]` is the environment's
         * average irradiance.
         */
        /**
         * 将辐照度设置为球谐函数。
         *
         * 辐照度必须通过 \f$ \langle n \cdot l \rangle \f$ 预卷积，并
         * 预乘 Lambert 漫反射 BRDF \f$ \frac{1}{\pi} \f$，然后
         * 指定为球谐函数系数。
         *
         * 此外，这些球谐函数系数必须通过以下
         * 重建因子 \f$ A_{l}^{m} \f$ 预缩放。
         *
         * 最终系数可以使用 `cmgen` 工具生成。
         *
         * \p sh 数组中的索引由下式给出：
         *
         *  `index(l, m) = l * (l + 1) + m`
         *
         *  \f$ sh[index(l,m)] = L_{l}^{m} \frac{1}{\pi} A_{l}^{m} \hat{C_{l}} \f$
         *
         * 仅允许 1、2 或 3 个频带。
         *
         * @param bands     球谐函数频带数。必须是 1、2 或 3。
         * @param sh        包含球谐函数系数的数组。
         *                  数组大小必须是 \f$ bands^{2} \f$。
         *                  （即分别为 1、4 或 9 个系数）。
         *
         * @return 此 Builder，用于链接调用。
         *
         * @see Material::Builder::sphericalHarmonicsBandCount()
         *
         * @note
         * 因为系数是预缩放的，所以 `sh[0]` 是环境的
         * 平均辐照度。
         */
        Builder& irradiance(uint8_t bands, math::float3 const* UTILS_NONNULL sh) noexcept;

        /**
         * Sets the irradiance from the radiance expressed as Spherical Harmonics.
         *
         * The radiance must be specified as Spherical Harmonics coefficients \f$ L_{l}^{m} \f$
         *
         * The index in the \p sh array is given by:
         *
         *  `index(l, m) = l * (l + 1) + m`
         *
         *  \f$ sh[index(l,m)] = L_{l}^{m} \f$
         *
         *   index |  l  |  m
         *  :-----:|:---:|:---:
         *     0   |  0  |  0
         *     1   |  1  | -1
         *     2   |  ^  |  0
         *     3   |  ^  |  1
         *     4   |  2  | -2
         *     5   |  ^  | -1
         *     6   |  ^  |  0
         *     7   |  ^  |  1
         *     8   |  ^  |  2
         *
         * @param bands     Number of spherical harmonics bands. Must be 1, 2 or 3.
         * @param sh        Array containing the spherical harmonics coefficients.
         *                  The size of the array must be \f$ bands^{2} \f$.
         *                  (i.e. 1, 4 or 9 coefficients respectively).
         *
         * @return This Builder, for chaining calls.
         */
        /**
         * 从以球谐函数表示的辐射度设置辐照度。
         *
         * 辐射度必须指定为球谐函数系数 \f$ L_{l}^{m} \f$
         *
         * \p sh 数组中的索引由下式给出：
         *
         *  `index(l, m) = l * (l + 1) + m`
         *
         *  \f$ sh[index(l,m)] = L_{l}^{m} \f$
         *
         * @param bands     球谐函数频带数。必须是 1、2 或 3。
         * @param sh        包含球谐函数系数的数组。
         *                  数组大小必须是 \f$ bands^{2} \f$。
         *                  （即分别为 1、4 或 9 个系数）。
         *
         * @return 此 Builder，用于链接调用。
         */
        Builder& radiance(uint8_t bands, math::float3 const* UTILS_NONNULL sh) noexcept;

        /**
         * Sets the irradiance as a cubemap.
         *
         * The irradiance can alternatively be specified as a cubemap instead of Spherical
         * Harmonics coefficients. It may or may not be more efficient, depending on your
         * hardware (essentially, it's trading ALU for bandwidth).
         *
         * @param cubemap   Cubemap representing the Irradiance pre-convolved by
         *                  \f$ \langle n \cdot l \rangle \f$.
         *
         * @return This Builder, for chaining calls.
         *
         * @note
         * This irradiance cubemap can be generated with the **cmgen** tool.
         *
         * @see irradiance(uint8_t bands, math::float3 const* sh)
         */
        /**
         * 将辐照度设置为立方体贴图。
         *
         * 辐照度也可以指定为立方体贴图而不是球谐函数
         * 系数。这可能更高效，也可能不会，取决于你的
         * 硬件（本质上，这是用 ALU 换取带宽）。
         *
         * @param cubemap   表示通过
         *                  \f$ \langle n \cdot l \rangle \f$ 预卷积的辐照度的立方体贴图。
         *
         * @return 此 Builder，用于链接调用。
         *
         * @note
         * 此辐照度立方体贴图可以使用 **cmgen** 工具生成。
         *
         * @see irradiance(uint8_t bands, math::float3 const* sh)
         */
        Builder& irradiance(Texture const* UTILS_NULLABLE cubemap) noexcept;

        /**
         * (optional) Environment intensity.
         *
         * Because the environment is encoded usually relative to some reference, the
         * range can be adjusted with this method.
         *
         * @param envIntensity  Scale factor applied to the environment and irradiance such that
         *                      the result is in lux, or lumen/m^2 (default = 30000)
         *
         * @return This Builder, for chaining calls.
         */
        /**
         * （可选）环境强度。
         *
         * 因为环境通常相对于某个参考值进行编码，所以可以使用此方法
         * 调整范围。
         *
         * @param envIntensity  应用于环境和辐照度的缩放因子，使得
         *                      结果以勒克斯（lux）或流明/平方米（lumen/m^2）为单位（默认值 = 30000）
         *
         * @return 此 Builder，用于链接调用。
         */
        Builder& intensity(float envIntensity) noexcept;

        /**
         * Specifies the rigid-body transformation to apply to the IBL.
         *
         * @param rotation 3x3 rotation matrix. Must be a rigid-body transform.
         *
         * @return This Builder, for chaining calls.
         */
        /**
         * 指定要应用于 IBL 的刚体变换。
         *
         * @param rotation 3x3 旋转矩阵。必须是刚体变换。
         *
         * @return 此 Builder，用于链接调用。
         */
        Builder& rotation(math::mat3f const& rotation) noexcept;

        /**
         * Creates the IndirectLight object and returns a pointer to it.
         *
         * @param engine Reference to the filament::Engine to associate this IndirectLight with.
         *
         * @return pointer to the newly created object or nullptr if exceptions are disabled and
         *         an error occurred.
         *
         * @exception utils::PostConditionPanic if a runtime error occurred, such as running out of
         *            memory or other resources.
         * @exception utils::PreConditionPanic if a parameter to a builder function was invalid.
         */
        /**
         * 创建 IndirectLight 对象并返回指向它的指针。
         *
         * @param engine 要与此 IndirectLight 关联的 filament::Engine 的引用。
         *
         * @return 指向新创建对象的指针，如果禁用异常且
         *         发生错误则为 nullptr。
         *
         * @exception utils::PostConditionPanic 如果发生运行时错误，例如用完
         *           内存或其他资源。
         * @exception utils::PreConditionPanic 如果构建器函数的参数无效。
         */
        IndirectLight* UTILS_NONNULL build(Engine& engine);

    private:
        friend class FIndirectLight;
    };

    /**
     * Sets the environment's intensity.
     *
     * Because the environment is encoded usually relative to some reference, the
     * range can be adjusted with this method.
     *
     * @param intensity  Scale factor applied to the environment and irradiance such that
     *                   the result is in lux, or <i>lumen/m^2</i> (default = 30000)
     */
    /**
     * 设置环境的强度。
     *
     * 因为环境通常相对于某个参考值进行编码，所以可以使用此方法
     * 调整范围。
     *
     * @param intensity  应用于环境和辐照度的缩放因子，使得
     *                   结果以勒克斯（lux）或<i>流明/平方米</i>（lumen/m^2）为单位（默认值 = 30000）
     */
    void setIntensity(float intensity) noexcept;

    /**
     * Returns the environment's intensity in <i>lux</i>, or <i>lumen/m^2</i>.
     */
    /**
     * 返回环境的强度，单位为<i>勒克斯</i>（lux）或<i>流明/平方米</i>（lumen/m^2）。
     */
    float getIntensity() const noexcept;

    /**
     * Sets the rigid-body transformation to apply to the IBL.
     *
     * @param rotation 3x3 rotation matrix. Must be a rigid-body transform.
     */
    /**
     * 设置要应用于 IBL 的刚体变换。
     *
     * @param rotation 3x3 旋转矩阵。必须是刚体变换。
     */
    void setRotation(math::mat3f const& rotation) noexcept;

    /**
     * Returns the rigid-body transformation applied to the IBL.
     */
    /**
     * 返回应用于 IBL 的刚体变换。
     */
    const math::mat3f& getRotation() const noexcept;

    /**
     * Returns the associated reflection map, or null if it does not exist.
     */
    /**
     * 返回关联的反射贴图，如果不存在则返回 null。
     */
    Texture const* UTILS_NULLABLE getReflectionsTexture() const noexcept;

    /**
     * Returns the associated irradiance map, or null if it does not exist.
     */
    /**
     * 返回关联的辐照度贴图，如果不存在则返回 null。
     */
    Texture const* UTILS_NULLABLE getIrradianceTexture() const noexcept;

    /**
     * Helper to estimate the direction of the dominant light in the environment represented by
     * spherical harmonics.
     *
     * This assumes that there is only a single dominant light (such as the sun in outdoors
     * environments), if it's not the case the direction returned will be an average of the
     * various lights based on their intensity.
     *
     * If there are no clear dominant light, as is often the case with low dynamic range (LDR)
     * environments, this method may return a wrong or unexpected direction.
     *
     * The dominant light direction can be used to set a directional light's direction,
     * for instance to produce shadows that match the environment.
     *
     * @param sh        3-band spherical harmonics
     *
     * @return A unit vector representing the direction of the dominant light
     *
     * @see LightManager::Builder::direction()
     * @see getColorEstimate()
     */
    /**
     * 帮助估算由球谐函数表示的环境中主导光的方向。
     *
     * 这假设只有一个主导光（例如户外环境中的太阳），如果不是这种情况，
     * 返回的方向将是根据各种光的强度计算的平均值。
     *
     * 如果没有明确的主导光，这在低动态范围（LDR）
     * 环境中很常见，此方法可能返回错误或意外的方向。
     *
     * 主导光方向可用于设置定向光的方向，
     * 例如产生与环境匹配的阴影。
     *
     * @param sh        3 频带球谐函数
     *
     * @return 表示主导光方向的单位向量
     *
     * @see LightManager::Builder::direction()
     * @see getColorEstimate()
     */
    static math::float3 getDirectionEstimate(const math::float3 sh[UTILS_NONNULL 9]) noexcept;

    /**
     * Helper to estimate the color and relative intensity of the environment represented by
     * spherical harmonics in a given direction.
     *
     * This can be used to set the color and intensity of a directional light. In this case
     * make sure to multiply this relative intensity by the the intensity of this indirect light.
     *
     * @param sh        3-band spherical harmonics
     * @param direction a unit vector representing the direction of the light to estimate the
     *                  color of. Typically this the value returned by getDirectionEstimate().
     *
     * @return A vector of 4 floats where the first 3 components represent the linear color and
     *         the 4th component represents the intensity of the dominant light
     *
     * @see LightManager::Builder::color()
     * @see LightManager::Builder::intensity()
     * @see getDirectionEstimate, getIntensity, setIntensity
     */
    /**
     * 帮助估算由球谐函数表示的环境在给定方向上的颜色和相对强度。
     *
     * 这可用于设置定向光的颜色和强度。在这种情况下，
     * 请确保将此相对强度乘以此间接光的强度。
     *
     * @param sh        3 频带球谐函数
     * @param direction 表示要估算颜色
     *                  的光方向的单位向量。通常这是 getDirectionEstimate() 返回的值。
     *
     * @return 一个 4 个浮点数的向量，其中前 3 个分量表示线性颜色，
     *         第 4 个分量表示主导光的强度
     *
     * @see LightManager::Builder::color()
     * @see LightManager::Builder::intensity()
     * @see getDirectionEstimate, getIntensity, setIntensity
     */
    static math::float4 getColorEstimate(const math::float3 sh[UTILS_NONNULL 9],
            math::float3 direction) noexcept;

    /**
     * Helper to estimate the direction of the dominant light in the environment represented by
     * spherical harmonics.
     * Spherical harmonics must be set in the Builder or the result is undefined.
     * @see getDirectionEstimate(const math::float3)
     * @see Builder::irradiance(uint8_t, math::float3 const*)
     * @see Builder::radiance(uint8_t, math::float3 const*)
     */
    /**
     * 帮助估算由球谐函数表示的环境中主导光的方向。
     * 必须在 Builder 中设置球谐函数，否则结果未定义。
     * @see getDirectionEstimate(const math::float3)
     * @see Builder::irradiance(uint8_t, math::float3 const*)
     * @see Builder::radiance(uint8_t, math::float3 const*)
     */
    math::float3 getDirectionEstimate() const noexcept;

    /**
     * Helper to estimate the color and relative intensity of the environment represented by
     * spherical harmonics in a given direction.
     * Spherical harmonics must be set in the Builder or the result is undefined.
     * @see getColorEstimate(const math::float3, math::float3)
     * @see Builder::irradiance(uint8_t, math::float3 const*)
     * @see Builder::radiance(uint8_t, math::float3 const*)
     */
    /**
     * 帮助估算由球谐函数表示的环境在给定方向上的颜色和相对强度。
     * 必须在 Builder 中设置球谐函数，否则结果未定义。
     * @see getColorEstimate(const math::float3, math::float3)
     * @see Builder::irradiance(uint8_t, math::float3 const*)
     * @see Builder::radiance(uint8_t, math::float3 const*)
     */
    math::float4 getColorEstimate(math::float3 direction) const noexcept;

protected:
    // prevent heap allocation
    ~IndirectLight() = default;
};

} // namespace filament

#endif // TNT_FILAMENT_INDIRECTLIGHT_H
